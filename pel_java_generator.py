#for creating the java classes from the pel json file
import json
import os
import sys
import warnings

def main():

    #creates the enum classes for each of the power usages in the json file
    file = open("pel.json", "r")
    data = json.load(file)
    path = "src/main/java/demosystem/models/pel"
    powerList = data["power_loads"]
    for item in powerList:
        oName = item["name"]
        if item["load_type"] == "states":
            fName = item["name"] + "_State"
            filepath = os.path.join(path, fName + ".java")
            newF = open(filepath, "w")
            stateList = []
            cbeLoadList = []
            mevLoadList = []
            for ent in item["power_states"]:
                stateList.append(ent["state"].upper())
                cbeLoadList.append(ent["CBE_power_usage"]["value"])
                mevLoadList.append(ent["MEV_power_usage"]["value"])

            body = f"""package demosystem.models.pel;
/**
* This class was created by the pel_java_generator.py script and represents the state(s) of the {oName} as an enum and associates
* a power load amount to each state.
*/
public enum {fName} {{\n"""
            for num in range(len(stateList)):
                if num != (len(stateList) - 1):
                    state = stateList[num].upper()
                    body = body + "\t" + state + "(" + str(cbeLoadList[num]) + ", " + str(mevLoadList[num]) + ")" + ",\n"
                else:
                    state = stateList[num].upper()
                    body = body + "\t" + state + "(" + str(cbeLoadList[num]) + ", " + str(mevLoadList[num]) + ");"+ "\n"
            newF.write(body)
            constructor = f"""    private final double cbeload;
    private final double mevload;
    {fName}(double cbeload, double mevload) {{
        this.cbeload = cbeload;  //in Watts
        this.mevload = mevload; //in Watts
    }}
    
    /**
    * Function that returns the cbe load of state of the instrument.
    * @return the power needed for that state
    */
    public double getCBELoad() {{
        return cbeload;  
    }}
    
    /**
    * Function that returns the mev load of state of the instrument.
    * @return the power needed for that state
    */
    public double getMEVLoad() {{
        return mevload;  
    }}
}}
"""
            newF.write(constructor)
            newF.close()


    # Make a PEL model class that contains an instance of the power usage enum classes and this class interacts with the Battery class
    pelPath = os.path.join(path, "PELModel.java")
    pelFile = open(pelPath, "w")
    initial = f"""package demosystem.models.pel;
    
import gov.nasa.jpl.aerie.contrib.streamline.modeling.Registrar;
import gov.nasa.jpl.aerie.contrib.serialization.mappers.EnumValueMapper;
import gov.nasa.jpl.aerie.contrib.serialization.mappers.DoubleValueMapper;

import gov.nasa.jpl.aerie.contrib.streamline.core.Resource;
import gov.nasa.jpl.aerie.contrib.streamline.core.MutableResource;
import gov.nasa.jpl.aerie.contrib.streamline.modeling.discrete.Discrete;

import static gov.nasa.jpl.aerie.contrib.streamline.modeling.discrete.DiscreteResources.add;
import static gov.nasa.jpl.aerie.contrib.streamline.modeling.discrete.monads.DiscreteResourceMonad.map;
    
/**
* This class is generated by the pel_java_generator.py script. It represents the PEL, which should contains all the
* possible spacecraft components that produce a power load on the spacecraft. For components whose loads are 
* represented by different states, the component state will also be registered as a resource.
*/
public class PELModel {{
    
    public Resource<Discrete<Double>> cbeTotalLoad;
    public Resource<Discrete<Double>> mevTotalLoad;\n"""

    construct = f"""    public PELModel() {{\n"""
    cbeTotalLoad = f"""        this.cbeTotalLoad = add("""
    mevTotalLoad = f"""        this.mevTotalLoad = add("""

    register = f"""    public void registerStates(Registrar registrar) {{\n"""
    for x in range(len(powerList)):
        name = powerList[x]["name"]
        loadType = powerList[x]["load_type"]
        if loadType == 'states':
            resourceName = name.lower() + "State"
            loadName = name.lower() + "Load"
        elif loadType == 'dynamic':
            resourceName = name.lower() + "Power"
            loadName = name.lower() + "Power"
        else:
            raise Exception("No load_type in PEL defined for " + name)

        if loadType == 'states':
            initial = initial + "\tpublic MutableResource<Discrete<" + name + "_State>> " + resourceName + ";\n"
            # Currently assuming state is initialized to first state in the list (may want to get fancier later)
            stateName = powerList[x]["power_states"][0]["state"].upper()
            construct = construct + "\t\tthis." + resourceName + " = MutableResource.resource( Discrete.discrete(" + name + "_State." + stateName + "));\n"

            # Add CBE/MEV load resources for each state
            initial = initial + "\tpublic Resource<Discrete<Double>> " + loadName + "_CBE;\n"
            initial = initial + "\tpublic Resource<Discrete<Double>> " + loadName + "_MEV;\n"
            # Add constructor for each new CBE/MEV load resource
            construct = construct + "\t\tthis." + loadName + "_CBE = map( " + resourceName + ", " + name + "_State::getCBELoad);\n"
            construct = construct + "\t\tthis." + loadName + "_MEV = map( " + resourceName + ", " + name + "_State::getMEVLoad);\n"

        elif loadType == 'dynamic':
            # Add CBE/MEV load resources for each state
            initial = initial + "\tpublic MutableResource<Discrete<Double>> " + resourceName + "_CBE;\n"
            initial = initial + "\tpublic Resource<Discrete<Double>> " + resourceName + "_MEV;\n"
            # Add constructor for each new CBE/MEV load resource
            # Currently assuming dynamic load is initialized to 0.0
            construct = construct + "\t\tthis." + resourceName + "_CBE = MutableResource.resource( Discrete.discrete(0.0));\n"
            if "MEV_factor" in powerList[x]:
                mevfactor = str(powerList[x]["MEV_factor"])
            else:
                warnings.warn("No MEV_factor specified for dynamic load " + name + ". Assume a factor of 1.0.")
                mevfactor = "1.0"
            construct = construct + "\t\tthis." + resourceName + "_MEV = map( " + resourceName + "_CBE, s -> s*" + mevfactor + ");\n"

        if loadType == 'states':
            register = register + "\t\tregistrar.discrete(\"" + resourceName + "\"," + resourceName + ", new EnumValueMapper<>(" + name + "_State.class));\n"
        elif loadType == 'dynamic':
            register = register + "\t\tregistrar.discrete(\"" + resourceName + "_CBE\"," + resourceName + "_CBE, new DoubleValueMapper());\n"
            register = register + "\t\tregistrar.discrete(\"" + resourceName + "_MEV\"," + resourceName + "_MEV, new DoubleValueMapper());\n"

        if x == (len(powerList) - 1):

            cbeTotalLoad = cbeTotalLoad + loadName + "_CBE);\n"
            mevTotalLoad = mevTotalLoad + loadName + "_MEV);\n"
            construct = construct + cbeTotalLoad + mevTotalLoad + "\n\t}\n"
            register = register + "\t\tregistrar.discrete(\"spacecraft.cbeLoad\", cbeTotalLoad, new DoubleValueMapper());\n" + "\t\tregistrar.discrete(\"spacecraft.mevLoad\", mevTotalLoad, new DoubleValueMapper());\n\t}\n}"
        else:
            cbeTotalLoad = cbeTotalLoad + loadName + "_CBE,"
            mevTotalLoad = mevTotalLoad + loadName + "_MEV,"

    pelFile.write(initial)
    pelFile.write(construct)
    pelFile.write(register)
    pelFile.close()


if __name__ == "__main__":
    main()  # pragma: no cover
                        
