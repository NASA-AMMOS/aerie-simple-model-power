package genericpowersystem.models.power;


import gov.nasa.jpl.aerie.merlin.framework.ModelActions;
//import gov.nasa.jpl.aerie.merlin.framework.resources.real.RealResource;
//import gov.nasa.jpl.aerie.merlin.framework.Resource;

public class GenericSolarArray {
    public double solarIntensity = 1367; //in W/m^2
    public double solarConstant = 0.07;  //to use when solar array is not completely deployed and not producing max power with area
    public double irrLosses = 0.984 * 0.94 * 0.99; //represents the irradiance losses (losses because of the material of the array)
    public SettableState<Boolean> solarArrayDeploymentComplete; //whether the solar array is fully deployed
    public SettableState<Boolean> solarArrayDeploymentStarted;  //whether the solar array has started deploying and therefore produces some power
    public DerivedState<Double> solarInputPower;   //represents current/power flowing into battery
    public SettableState<Double> distance;  //distance of spacecraft from the Sun in AU
    public SettableState<Double> angle;  //angle between the suns rays and the normal vector of the surface of the solar array (because of the spacecraft's orientation)
    public SettableState<Double> area;  //area of the solar array
    public DistAndAngleCalculator calculator;  //has functions that allows distance and angle to change on their own


    public GenericSolarArray(double area) {
        this.solarArrayDeploymentComplete = SettableState.builder(Boolean.class).initialValue(false).build();
        this.solarArrayDeploymentStarted = SettableState.builder(Boolean.class).initialValue(false).build();
        this.distance = SettableState.builder(Double.class).initialValue(0.0).build();
        this.angle = SettableState.builder(Double.class).initialValue(-90.0).build();
        this.area = SettableState.builder(Double.class).initialValue(area).build();

        this.solarInputPower = DerivedState.builder(Double.class)
                .sourceStates(this.solarArrayDeploymentComplete, this.solarArrayDeploymentStarted, this.distance, this.angle)
                .valueFunction(this::computeSolarPower)
                .build();

        this.calculator = new DistAndAngleCalculator(this);
        ModelActions.spawn(calculator::run);
    }


    //computes the solar power generated by the array based on distance, angle, deployment, and the solar intensity
    //after computing the solar power, it also updates the net power of the battery
    public double computeSolarPower() {
        if (solarArrayDeploymentStarted.get() && !solarArrayDeploymentComplete.get()) {
            return (irrLosses * solarConstant * (solarIntensity / (distance.get() * distance.get())) * Math.cos(Math.toRadians(angle.get())) * area.get());
        } else if (solarArrayDeploymentComplete.get()) {
           return (irrLosses * (solarIntensity / (distance.get() * distance.get())) * Math.cos(Math.toRadians(angle.get())) * area.get());
        } else {
            return 0.0;
        }
        //return (irrLosses * (solarIntensity / (distance.get() * distance.get())) * Math.cos(Math.toRadians(angle.get())) * area.get());
    }

    //when the solar arrays have deployed
    //recomputes the solar power based on the changed attributes of the array
    public void endSolarArrayDeployment() {
        this.solarArrayDeploymentComplete.set(true);
        this.solarArrayDeploymentStarted.set(false);
    }

    //when the solar arrays have started to deploy
    //recomputes the solar power based on the changed attributes of the array
    public void startSolarArrayDeployment() {
        this.solarArrayDeploymentComplete.set(false);
        this.solarArrayDeploymentStarted.set(true);
    }

    //to represent closing the arrays (no longer generating solar power)
    public void closeSolarArrays() {
        this.solarArrayDeploymentComplete.set(false);
        this.solarArrayDeploymentStarted.set(false);
    }

}