package powersystem;


import gov.nasa.jpl.aerie.merlin.framework.Resource;
import gov.nasa.jpl.aerie.merlin.framework.Registrar;
import gov.nasa.jpl.aerie.contrib.serialization.mappers.DoubleValueMapper;

/**
 * This class represents the power generation for the spacecraft using a solar array. The solar array is associated with
 * a battery model, and it supplies power to the spacecraft and the battery. It is part of the overall power system.
 */

public class GenericSolarArray {
    public final double solarIntensityAtEarth = 1360.8; //solar irradiance from the sun at 1 AU (W/m^2)
    public double solarConstant = 0.07;  //to use when solar array is not completely deployed and not producing max power with arrayCellArea
    public double irrLosses = 0.984 * 0.94 * 0.99; //represents the irradiance losses (losses because of the material of the array)
    public SettableState<Boolean> solarArrayDeploymentComplete; //whether the solar array is fully deployed
    public SettableState<Boolean> solarArrayDeploymentStarted;  //whether the solar array has started deploying and therefore produces some power
    public DerivedState<Double> powerProduction;   //total power produced by the solar arrays (W)
    public SettableState<Double> solarDistance;  //spacecraft distance from the Sun (AU)
    public SettableState<Double> arrayToSunAngle;  //angle between the Sun and the array surface normal vector due to spacecraft orientation (deg)
    public SettableState<Double> arrayCellArea;  //area of the solar arrays containing solar cells (m^2) that can produce power
    //public DistAndAngleCalculator calculator;  //has functions that allows distance and arrayToSunAngle to change on their own

    /**
     * Constructor for the solar array
     * @param arrayCellArea the arrayCellArea of the solar array in m^2
     */
    public GenericSolarArray(Resource<Double> arrayCellArea, Resource<Double> solarDistance, Resource<Double> arrayToSunAngle) {
        this.solarArrayDeploymentComplete = SettableState.builder(Boolean.class).initialValue(false).build();
        this.solarArrayDeploymentStarted = SettableState.builder(Boolean.class).initialValue(false).build();
        this.solarDistance = (SettableState<Double>) solarDistance;
        this.arrayToSunAngle = (SettableState<Double>) arrayToSunAngle;
        this.arrayCellArea = (SettableState<Double>) arrayCellArea;

        this.powerProduction = DerivedState.builder(Double.class)
                .sourceStates(this.solarDistance, this.arrayToSunAngle, this.solarArrayDeploymentComplete, this.solarArrayDeploymentStarted)
                .valueFunction(this::computeSolarPower)
                .build();
    }

    /**
     * Computes the solar power generated by the array associated with the battery based on distance, arrayToSunAngle, arrayCellArea of the
     * array, and solar intensity - value changes based on whether the solar array is fully deployed or not
     * Since net power is dependent on this, when solar power value changes so does the net power value
     * @return the solar power
     */
    public double computeSolarPower() {
        if (solarArrayDeploymentStarted.get() && !solarArrayDeploymentComplete.get()) {
            return (irrLosses * solarConstant * (solarIntensityAtEarth / (solarDistance.get() * solarDistance.get())) * Math.cos(Math.toRadians(arrayToSunAngle.get())) * arrayCellArea.get());
        } else if (solarArrayDeploymentComplete.get()) {
           return (irrLosses * (solarIntensityAtEarth / (solarDistance.get() * solarDistance.get())) * Math.cos(Math.toRadians(arrayToSunAngle.get())) * arrayCellArea.get());
        } else {
            return 0.0;
        }
    }

    /**
     * Method to represent when the solar arrays have fully deployed and are producing as much power as they can,
     * recomputes the solar power based on the changed attributes of the array
     */
    public void endSolarArrayDeployment() {
        this.solarArrayDeploymentComplete.set(true);
        this.solarArrayDeploymentStarted.set(false);
    }

    /**
     * Method to represent that the solar arrays have started to deploy, it is not producing the max amount of power it
     * can, recomputes the solar power based on the changed attributes of the array
     */
    public void startSolarArrayDeployment() {
        this.solarArrayDeploymentComplete.set(false);
        this.solarArrayDeploymentStarted.set(true);
    }

    /**
     * Method for Aerie to register the resources in this model
     * @param registrar how Aerie knows what the resources are
     */
    public void registerStates(Registrar registrar) {
        registrar.discrete("array.powerProduction", powerProduction, new DoubleValueMapper());
        registrar.discrete("spacecraft.solarDistance", solarDistance, new DoubleValueMapper());
        registrar.discrete("spacecraft.arrayToSunAngle", arrayToSunAngle, new DoubleValueMapper());
    }
}