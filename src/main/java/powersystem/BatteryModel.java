package powersystem;

import gov.nasa.jpl.aerie.contrib.serialization.mappers.DoubleValueMapper;
import gov.nasa.jpl.aerie.merlin.framework.ModelActions;
import gov.nasa.jpl.aerie.merlin.framework.Registrar;
import gov.nasa.jpl.aerie.merlin.framework.resources.real.RealResource;
import gov.nasa.jpl.aerie.merlin.framework.Resource;



/**
 * This class represents the battery of a spacecraft. It is tied to a power source (e.g. solar array) and the power load
 * of the spacecraft. The battery's state of charge is dependent on the net power - the difference between how much power
 * is being generated by the source and how much power is demanded the spacecraft. The battery state of charge is simply
 * a function the net power over time.
 */

public class BatteryModel {
    public String name;
    public double busVoltage;  //the voltage of the battery in volts
    public double batteryCapacityAH; //the battery's capacity in amp-hours
    public double batteryCapacityWH; //the battery's capacity in watt-hours
    public DerivedState<Double> actualNetPowerW;  //represents the net power into/out of the battery
    public DerivedState<Double> battNetPowerW;   //net power for the computation of batterySOC
    public DerivedState<Double> powerLoadW; //represents how much power is required by the spacecraft, connected to the PEL
    public RealResource batterySOC;  //the state of charge of the battery
    //public DerivedState<Double> batterySOC;
    public SettableState<Boolean> batteryFull;  //whether the battery is at 100% or not
    public SettableState<Boolean> batteryEmpty;  //whether the battery is at 0% or not
    public DerivedState<Double> solarPower;    //the source power, how much solar power the spacecraft is generating
    public IntegratedState integratedNetPower;   //the integration of the net power, represents how much the battery was
                                                // charged/discharged and helps calculate the SOC
    public BatterySOCController controller; //helpful in determining what state the battery is in (full or empty) and
                                            // limits the integrated net power between 0 to battery capacity in watt-hours
    public boolean startOfSim;      //determines whether the simulation just started and helps the battery SOC equal 100%

    /**
     * The constructor for the battery model
     * @param busVoltage the voltage of the battery
     * @param batteryCapacityAH the capacity of the battery in amp-hours
     * //@param initialBatterySOC the initial battery state of charge
     */

    public BatteryModel(double busVoltage, double batteryCapacityAH, Resource<Double> totalLoad, Resource<Double> inputPower, String name) {
        this.busVoltage = busVoltage;
        this.name = name;
        this.startOfSim = true;
        this.batteryCapacityAH = batteryCapacityAH;
        this.batteryCapacityWH = this.batteryCapacityAH * this.busVoltage;
        this.powerLoadW = (DerivedState<Double>) totalLoad;
        this.solarPower = (DerivedState<Double>) inputPower;
        this.batteryFull = SettableState.builder(Boolean.class).initialValue(true).build();
        this.batteryEmpty = SettableState.builder(Boolean.class).initialValue(false).build();
        this.actualNetPowerW = DerivedState.builder(Double.class)
                .sourceStates(this.solarPower, this.powerLoadW)
                .valueFunction(this::computeNetPowerW)
                .build();
        this.battNetPowerW = DerivedState.builder(Double.class)
                .sourceStates(this.solarPower, this.powerLoadW, this.batteryFull, this.batteryEmpty)
                .valueFunction(this::netPowerWBattery)
                .build();
        this.integratedNetPower = IntegratedState.builder()
                .integrandState(this.battNetPowerW)
                .initialValue(0.0)
                .build();
/**
        this.batterySOC = DerivedState.builder(Double.class)
                .sourceStates(this.netPowerW)
                .valueFunction(this::updateSOC)
                .build();
 */
        this.batterySOC = RealResource.scaleBy(1.0/batteryCapacityWH, this.integratedNetPower).scaledBy(100);
        this.controller = new BatterySOCController(this);
        ModelActions.spawn(controller::run);
    }


    /**
     * Function that computes the actual net power of the spacecraft based on how much power is being generated by the solar
     * array and how much power is required by the spacecraft (the power load)
     * @return the net power of the system
     */
    public double computeNetPowerW() {
        return solarPower.get() - powerLoadW.get();
    }


    /**
     * Function that is useful is determining the integrated net power and the battery SOC, helps limit the integrated
     * power from 0 to battery capacity and the battery SOC from 0 to 100, a modified net power function
     * @return the net power to be used for the integrated power and the battery SOC
     */
    public double netPowerWBattery() {
        double net = (solarPower.get() - powerLoadW.get()) / 3600;
        if (startOfSim == true) {
            startOfSim = false;
            return busVoltage * batteryCapacityAH;
        }
        if (batteryFull.get()) {
            return Math.min(net, 0.0);
        } else if (batteryEmpty.get()) {
            return Math.max(net, 0.0);
        } else {
            return net;
        }
    }


    /**
     * Calculates the state of charge of the battery by integrating the net power and limiting the battery SOC based on
     * if it is full or empty
     * @return the battery SOC, a value between 0 and 100

    public double updateSOC() {
        double incCharge = (integratedNetPower.get() / batteryCapacityWH) * 100;
        if (batterySOC == null) {
            return this.initialBatterySOC + incCharge;
        }
        if ((batterySOC.get() + incCharge) > 100.0) {   //if current battery SOC + the power flowing in is greater than 100%, set the battery SOC to 100%
            return 100.0;
        } else if ((batterySOC.get() + incCharge) < 0.0) { //if the current battery SOC + the power flowing out is less than 0%, set the battery SOC to 0%
            return 0.0;
        }
        return (batterySOC.get() + incCharge);
    }
    */

    /**
     * Method for Aerie to register the resources in this model
     * @param registrar how Aerie knows what the resources are
     */
    public void registerStates(Registrar registrar) {
        registrar.discrete(name + "battery.battNetPowerW", battNetPowerW, new DoubleValueMapper());
        registrar.discrete(name + "battery.actualNetPowerW", actualNetPowerW, new DoubleValueMapper());
        registrar.real(name + "battery.batterySOC", batterySOC);
        registrar.real(name + "battery.integratedNetPower", integratedNetPower);
    }

}
