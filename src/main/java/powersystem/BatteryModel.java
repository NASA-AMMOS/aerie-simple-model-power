package powersystem;

import gov.nasa.jpl.aerie.contrib.serialization.mappers.BooleanValueMapper;
import gov.nasa.jpl.aerie.contrib.serialization.mappers.DoubleValueMapper;
import gov.nasa.jpl.aerie.merlin.framework.ModelActions;
import gov.nasa.jpl.aerie.merlin.framework.Registrar;
import gov.nasa.jpl.aerie.merlin.framework.resources.real.RealResource;
import gov.nasa.jpl.aerie.merlin.framework.Resource;

/**
 * This class represents the battery of a spacecraft. It is tied to a power source (e.g. solar array) and the total
 * power load (demand) of the spacecraft. The battery state of charge is a function of the current into and out of the
 * battery over time, which is dependent on the net power - the difference between how much power is being generated by
 * the source and how much power is demanded by the spacecraft. Battery specifications (e.g. size) and initial state
 * (e.g initial state of charge) are brought into this class via BatterySimConfig.
 */
public class BatteryModel {
    public String name; // Name of the model (creates prefixes on resource names)
    public BatterySimConfig simConfig; // Simulation configuration about the battery provides by planner
    public double busVoltage; // Voltage the spacecraft uses to distribute power to its various components (V).
                              // Also known as battery bus voltage
    public double batteryCapacityAH; // Battery capacity in amp-hours
    public double batteryCapacityWH; // Battery capacity in watt-hours
    public DerivedState<Double> batteryCurrent;   // Net power between the power source and demand (A)
    public DerivedState<Double> powerDemand; // Power required by the spacecraft, connected to the PEL (W)
    public RealResource batterySOC;  // State of charge of the battery (%)
    public SettableState<Boolean> batteryFull;  // Tracks whether the battery is at 100% or not
    public SettableState<Boolean> batteryEmpty;  // Tracks whether the battery is at 0% or not
    public DerivedState<Double> powerProduction;    // Amount of power generated by the spacecraft
    public IntegratedState batteryChargeSec;   // Current amount of charge in the battery (Amp-seconds)
    public RealResource batteryCharge;   // Current amount of charge in the battery (Ah)
    public BatterySOCController controller; // Simple controller to keep SOC within its correct bounds (between 0 and
                                            // 100%)

    /**
     * The constructor for the battery model
     * @param name Name of this battery model (creates prefixes on resource names to keep resource names unique)
     * @param batterySimConfig Simulation configuration about the battery provides by planner
     * @param totalLoad the total load on the spacecraft battery in Watts
     * @param powerProduction the total load on the spacecraft battery in Watts
     */
    public BatteryModel(String name, BatterySimConfig batterySimConfig, Resource<Double> totalLoad, Resource<Double> powerProduction) {
        this.simConfig = batterySimConfig;
        this.busVoltage = simConfig.busVoltage();
        this.name = name;
        this.batteryCapacityAH = simConfig.batteryCapacity();
        this.batteryCapacityWH = this.batteryCapacityAH * this.busVoltage;
        this.powerDemand = (DerivedState<Double>) totalLoad;
        this.powerProduction = (DerivedState<Double>) powerProduction;

        // Local variable for battery charge initialization since the battery charge resource must get initialized after
        // battery current to prevent circular dependency.
        double battery_charge = this.simConfig.initialSOC() * this.batteryCapacityAH / 100.0;

        if (battery_charge >= this.batteryCapacityAH) {
            this.batteryFull = SettableState.builder(Boolean.class).initialValue(true).build();
        } else {
            this.batteryFull = SettableState.builder(Boolean.class).initialValue(false).build();
        }

        if (battery_charge <= 0.0) {
            this.batteryEmpty = SettableState.builder(Boolean.class).initialValue(true).build();
        } else {
            this.batteryEmpty = SettableState.builder(Boolean.class).initialValue(false).build();
        }

        this.batteryCurrent = DerivedState.builder(Double.class)
                .sourceStates(this.powerProduction, this.powerDemand, this.batteryFull, this.batteryEmpty)
                .valueFunction(this::computeBatteryCurrent)
                .build();

        // Integrated states compute in units of seconds, but battery charge is in units of Amp-hours, hence the
        // factor of 3600
        this.batteryChargeSec = IntegratedState.builder()
                .integrandState(this.batteryCurrent)
                .initialValue(battery_charge * 3600.0)
                .build();

        // Conversion from units of seconds back to hours
        this.batteryCharge = RealResource.scaleBy(1.0/3600.0, this.batteryChargeSec);
        this.batterySOC = RealResource.scaleBy(1.0/batteryCapacityAH, this.batteryCharge).scaledBy(100);
        this.controller = new BatterySOCController(this);
        ModelActions.spawn(controller::run);
    }

    /**
     * Calculates the battery current into or out of the battery based on the difference between the current power
     * production and demand. Battery current is computed by simply dividing the net power between source and demand by
     * bus voltage (I = P/V).
     *
     * If the battery is full or out of juice, no current will be flowing to or from the battery.
     *
     * @return batteryCurrent
     */
    public double computeBatteryCurrent() {
        double batteryCurrent = (powerProduction.get() - powerDemand.get()) / busVoltage;
        if (batteryFull.get()) {
            return Math.min(batteryCurrent, 0.0);
        } else if (batteryEmpty.get()) {
            return Math.max(batteryCurrent, 0.0);
        } else {
            return batteryCurrent;
        }
    }

    /**
     * Method for Aerie to register the resources in this model so they can be viewed in the UI
     * @param registrar common object for which to register resources across models
     */
    public void registerStates(Registrar registrar) {
        registrar.discrete(name + "battery.batteryCurrent", batteryCurrent, new DoubleValueMapper());
        registrar.discrete(name + "battery.batteryFull", batteryFull, new BooleanValueMapper());
        registrar.discrete(name + "battery.batteryEmpty", batteryEmpty, new BooleanValueMapper());
        registrar.real(name + "battery.batterySOC", batterySOC);
        registrar.real(name + "battery.batteryCharge", batteryCharge);
        registrar.real(name + "battery.batteryChargeSec", batteryChargeSec);
    }

}
