package powersystem;

import gov.nasa.jpl.aerie.contrib.serialization.mappers.BooleanValueMapper;
import gov.nasa.jpl.aerie.contrib.serialization.mappers.DoubleValueMapper;

import gov.nasa.jpl.aerie.contrib.streamline.core.monads.ResourceMonad;
import gov.nasa.jpl.aerie.contrib.streamline.modeling.discrete.Discrete;
import gov.nasa.jpl.aerie.contrib.streamline.core.Resource;

import gov.nasa.jpl.aerie.contrib.streamline.modeling.linear.Linear;
import gov.nasa.jpl.aerie.contrib.streamline.modeling.polynomial.Polynomial;
import gov.nasa.jpl.aerie.contrib.streamline.modeling.polynomial.PolynomialResources;
import gov.nasa.jpl.aerie.contrib.streamline.modeling.Registrar;

import static gov.nasa.jpl.aerie.contrib.streamline.modeling.discrete.monads.DiscreteResourceMonad.map;
import static gov.nasa.jpl.aerie.contrib.streamline.modeling.polynomial.PolynomialResources.*;

/**
 * This class represents the battery of a spacecraft. It is tied to a power source (e.g. solar array) and the total
 * power load (demand) of the spacecraft. The battery state of charge is a function of the current into and out of the
 * battery over time, which is dependent on the net power - the difference between how much power is being generated by
 * the source and how much power is demanded by the spacecraft. Battery specifications (e.g. size) and initial state
 * (e.g initial state of charge) are brought into this class via BatterySimConfig.
 */
public class BatteryModel {
    public String name; // Name of the model (creates prefixes on resource names)
    public BatterySimConfig simConfig; // Simulation configuration about the battery provides by planner
    public double busVoltage; // Voltage the spacecraft uses to distribute power to its various components (V).
                              // Also known as battery bus voltage
    public double batteryCapacityAH; // Battery capacity in amp-hours
    public double batteryCapacityWH; // Battery capacity in watt-hours
    public Resource<Polynomial> batteryCurrent;   // Net power between the power source and demand (A)
    public Resource<Discrete<Double>> powerDemand; // Power required by the spacecraft, connected to the PEL (W)
    public Resource<Polynomial> batterySOC;  // State of charge of the battery (%)

    public Resource<Discrete<Double>> batteryCurrentUnclamped;  // State of charge of the battery (%)
    public Resource<Discrete<Boolean>> batteryFull;  // Tracks whether the battery is at 100% or not
    public Resource<Discrete<Boolean>> batteryEmpty;  // Tracks whether the battery is at 0% or not
    public Resource<Discrete<Double>> powerProduction;    // Amount of power generated by the spacecraft
    public Resource<Polynomial> batteryChargeSec;   // Current amount of charge in the battery (Amp-seconds)
    public Resource<Polynomial> batteryCharge;   // Current amount of charge in the battery (Ah)

    /**
     * The constructor for the battery model
     * @param name Name of this battery model (creates prefixes on resource names to keep resource names unique)
     * @param batterySimConfig Simulation configuration about the battery provides by planner
     * @param totalLoad the total load on the spacecraft battery in Watts
     * @param powerProduction the total load on the spacecraft battery in Watts
     */
    public BatteryModel(String name, BatterySimConfig batterySimConfig, Resource<Discrete<Double>> totalLoad, Resource<Discrete<Double>> powerProduction) {
        this.simConfig = batterySimConfig;
        this.busVoltage = simConfig.busVoltage();
        this.name = name;
        this.batteryCapacityAH = simConfig.batteryCapacity();
        this.batteryCapacityWH = this.batteryCapacityAH * this.busVoltage;
        this.powerDemand = totalLoad;
        this.powerProduction = powerProduction;

        // Local variable for battery charge initialization since the battery charge resource must get initialized after
        // battery current to prevent circular dependency.
        double battery_charge = this.batteryCapacityAH * this.simConfig.initialSOC() / 100.0;

        this.batteryCurrentUnclamped =  map(this.powerProduction, this.powerDemand, this::computeBatteryCurrent);

//        this.batteryCurrent =  bind(this.powerProduction, gncStateValue ->
//                               bind(this.powerDemand, telecomStateValue ->
//                               bind(this.batteryFull, avionicsStateValue ->
//                               map(this.batteryEmpty, this::computeBatteryCurrent))));


        // Integrated states compute in units of seconds, but battery charge is in units of Amp-hours, hence the
        // factor of 3600
        var clampedIntegrate = PolynomialResources.clampedIntegrate( asPolynomial(this.batteryCurrentUnclamped),
                PolynomialResources.constant(0.0),
                PolynomialResources.constant(this.batteryCapacityAH * 3600.0),
                battery_charge * 3600.0);

        this.batteryChargeSec = clampedIntegrate.integral();

        // Example of converting "down" to discrete resource
        // this.batteryCurrent = ResourceMonad.map(differentiate(this.batteryChargeSec), p -> Discrete.discrete(p.extract()));

        this.batteryCurrent = differentiate(this.batteryChargeSec);

        // Conversion from units of seconds back to hours
        this.batteryCharge = multiply( this.batteryChargeSec, PolynomialResources.constant(1.0/3600.0) );
        this.batterySOC = multiply( this.batteryCharge, PolynomialResources.constant (1.0/batteryCapacityAH * 100.0) );
        this.batteryFull = PolynomialResources.greaterThanOrEquals(this.batterySOC, 100.0);
        this.batteryEmpty = PolynomialResources.lessThanOrEquals(this.batterySOC, 0.0);

    }

    /**
     * Calculates the battery current into or out of the battery based on the difference between the current power
     * production and demand. Battery current is computed by simply dividing the net power between source and demand by
     * bus voltage (I = P/V).
     *
     * @return batteryCurrent
     */
    public double computeBatteryCurrent(Double powerProd, Double powerDemand) {
        return (powerProd - powerDemand) / this.busVoltage;
    }

    /**
     * Method for Aerie to register the resources in this model so they can be viewed in the UI
     * @param registrar common object for which to register resources across models
     */
    public void registerStates(Registrar registrar) {
        registrar.real(name + "battery.batteryCurrent",
                ResourceMonad.map(this.batteryCurrent, p -> Linear.linear( p.extract(), p.getCoefficient(1) )));
        registrar.discrete(name + "battery.batteryCurrentUnclamped", this.batteryCurrentUnclamped, new DoubleValueMapper() );
        registrar.discrete(name + "battery.batteryFull", batteryFull, new BooleanValueMapper());
        registrar.discrete(name + "battery.batteryEmpty", batteryEmpty, new BooleanValueMapper());
        registrar.real(name + "battery.batterySOC",
                ResourceMonad.map(this.batterySOC, p -> Linear.linear( p.extract(), p.getCoefficient(1) )));
        registrar.real(name + "battery.batteryCharge",
                ResourceMonad.map(this.batteryCharge, p -> Linear.linear( p.extract(), p.getCoefficient(1) )));
        registrar.real(name + "battery.batteryChargeSec",
                ResourceMonad.map(this.batteryChargeSec, p -> Linear.linear( p.extract(), p.getCoefficient(1) )));
    }

}
