package demosystem.models.pel;
    
import gov.nasa.jpl.aerie.merlin.framework.Registrar;
import gov.nasa.jpl.aerie.contrib.serialization.mappers.EnumValueMapper;
import gov.nasa.jpl.aerie.contrib.serialization.mappers.DoubleValueMapper;
import powersystem.SettableState;
import powersystem.DerivedState;
    
/**
* This class is generated by the pel_java_generator.py script. It represents the PEL, which should contains all the
* possible spacecraft components that produce a power load on the spacecraft. For components whose loads are 
* represented by different states, the component state will also be registered as a resource.
*/
public class PELModel {
    
    public DerivedState<Double> cbeTotalLoad;
    public DerivedState<Double> mevTotalLoad;
	public SettableState<GNC_State> gncState;
	public SettableState<Telecom_State> telecomState;
	public SettableState<Avionics_State> avionicsState;
	public SettableState<Camera_State> cameraState;
	public SettableState<Double> locomotionPower;
    public PELModel() {
		this.gncState = SettableState.builder(GNC_State.class).initialValue(GNC_State.NOMINAL).build();
		this.telecomState = SettableState.builder(Telecom_State.class).initialValue(Telecom_State.OFF).build();
		this.avionicsState = SettableState.builder(Avionics_State.class).initialValue(Avionics_State.ON).build();
		this.cameraState = SettableState.builder(Camera_State.class).initialValue(Camera_State.OFF).build();
		this.locomotionPower = SettableState.builder(Double.class).initialValue(0.0).build();
        this.cbeTotalLoad = DerivedState.builder(Double.class)
                .sourceStates(this.gncState,this.telecomState,this.avionicsState,this.cameraState,this.locomotionPower)
				.valueFunction(this::computeCBELoad)
				.build();
        this.mevTotalLoad = DerivedState.builder(Double.class)
                .sourceStates(this.gncState,this.telecomState,this.avionicsState,this.cameraState,this.locomotionPower)
				.valueFunction(this::computeMEVLoad)
				.build();
	}
    /**
    * Computes the CBE power load of the spacecraft by rolling up power values of each power load based on load state,
    * or for dynamic loads, power values for the load are queried directly (no state).
    * @return the power load of the spacecraft
    */
    public double computeCBELoad() {
        return this.gncState.get().getCBELoad() + 
				this.telecomState.get().getCBELoad() + 
				this.avionicsState.get().getCBELoad() + 
				this.cameraState.get().getCBELoad() + 
				this.locomotionPower.get();
	}

    /**
    * Computes the MEV power load of the spacecraft by rolling up power values of each power load based on load state,
    * or for dynamic loads, power values for the load are queried directly (no state) and multiplied a MEV load factor.
    * @return the power load of the spacecraft
    */
    public double computeMEVLoad() {
        return this.gncState.get().getMEVLoad() + 
				this.telecomState.get().getMEVLoad() + 
				this.avionicsState.get().getMEVLoad() + 
				this.cameraState.get().getMEVLoad() + 
				this.locomotionPower.get()*1.25;
	}
    public void registerStates(Registrar registrar) {
		registrar.discrete("gncState",gncState, new EnumValueMapper<>(GNC_State.class));
		registrar.discrete("telecomState",telecomState, new EnumValueMapper<>(Telecom_State.class));
		registrar.discrete("avionicsState",avionicsState, new EnumValueMapper<>(Avionics_State.class));
		registrar.discrete("cameraState",cameraState, new EnumValueMapper<>(Camera_State.class));
		registrar.discrete("spacecraft.cbeLoad", cbeTotalLoad, new DoubleValueMapper());
		registrar.discrete("spacecraft.mevLoad", mevTotalLoad, new DoubleValueMapper());
	}
}